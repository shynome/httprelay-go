package httprelay

import (
	"fmt"
	"net/http"
	"net/url"
	"path"
	"runtime"
	"sync"
	"time"

	"github.com/shynome/httprelay-go/fetch"
	"github.com/shynome/httprelay-go/handler"
)

type ProxyAuth struct {
	ID     string
	Secret string
}

type Proxy struct {
	ProxyUrl  string
	Parallel  int
	Auth      ProxyAuth
	client    *http.Client
	handler   http.Handler
	errRetry  int
	ServerUrl string
}

func NewProxy(proxyUrl string) *Proxy {
	return &Proxy{
		ProxyUrl: proxyUrl,
		Parallel: runtime.NumCPU(),
		Auth:     ProxyAuth{randStr(5), randStr(8)},
		client:   &http.Client{},
		errRetry: 0,
	}
}

func (p *Proxy) GetServerUrl() string {
	if p.ServerUrl != "" {
		return p.ServerUrl
	}
	u, err := url.Parse(p.ProxyUrl)
	if err != nil {
		panic(err)
	}
	u.Path = path.Join("/proxy", p.Auth.ID) + "/"
	p.ServerUrl = u.String()
	return p.ServerUrl
}

func (p *Proxy) Serve(h http.Handler) {
	if h == nil {
		h = http.DefaultServeMux
	}
	p.handler = h
	var wg sync.WaitGroup
	for i := 0; i < p.Parallel; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := p.serveLoop()
			if err != nil {
				fmt.Println(err)
			}
		}()
	}
	wg.Wait()
}

func (p *Proxy) serveLoop() (err error) {
	var init *fetch.RequestInit = nil
	for {
		init, err = p.serve(init)
		if err != nil {
			fmt.Println(err)
		}
		if init == nil {
			break
		}
	}
	return
}

func (p *Proxy) retry() *fetch.RequestInit {
	p.errRetry++
	errRetry := p.errRetry
	time.Sleep(time.Duration(errRetry) * time.Second)
	return p.defaultRequestInit()
}

func (p *Proxy) defaultRequestInit() *fetch.RequestInit {
	return handler.MakeRequestInit(p.Auth.Secret, http.Header{}, nil)
}

func (p *Proxy) serve(init *fetch.RequestInit) (rinit *fetch.RequestInit, err error) {
	if init == nil {
		init = p.defaultRequestInit()
	}
	resp, err := fetch.Run(p.client, p.GetServerUrl(), init)
	if err != nil {
		return
	}
	if resp.StatusCode != 200 {
		err = fmt.Errorf("HttpRelay responded %v while returning result and requesting new job", resp.StatusCode)
		if resp.StatusCode >= 500 && resp.StatusCode <= 599 {
			// retry
			rinit = p.retry()
			return
		}
		if resp.StatusCode == 406 {
			err = fmt.Errorf("%e Client is gone, nowhere to forward the response", err)
			// contine
			rinit = p.defaultRequestInit()
			return
		}
		// don't continue
		if resp.StatusCode == 401 {
			err = fmt.Errorf("%e Make sure that provided `wSecret` is correct. If not set, it is autogenerated each time `proxy` object is created and most of the time it is the reason you get this error", err)
			return
		}
		return
	}
	p.errRetry = 0
	h := handler.Handler{
		Handler: p.handler,
		Secret:  p.Auth.Secret,
	}
	hreq, err := handler.NewRequest(resp)
	if err != nil {
		rinit = p.retry()
		return
	}
	ctx := handler.Context{Request: hreq, Secret: h.Secret}
	rinit = h.Execute(ctx)
	return
}
