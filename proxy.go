package httprelay

import (
	"fmt"
	"math"
	"net/http"
	"net/url"
	"path"
	"runtime"
	"sync"
	"time"

	"github.com/shynome/httprelay-go/fetch"
	"github.com/shynome/httprelay-go/handler"
)

type ProxyAuth struct {
	ID     string
	Secret string
}

type ProxyErrRetry struct {
	Max      uint
	Count    uint
	Interval time.Duration
}

type Proxy struct {
	ProxyUrl  string
	Parallel  int
	Auth      ProxyAuth
	Client    *http.Client
	handler   http.Handler
	ErrRetry  *ProxyErrRetry
	ServerUrl string
	Println   func(...interface{})
}

func NewProxy(proxyUrl string) *Proxy {
	return &Proxy{
		ProxyUrl: proxyUrl,
		Parallel: runtime.NumCPU(),
		Auth:     ProxyAuth{randStr(5), randStr(8)},
		Client:   http.DefaultClient,
		Println:  func(i ...interface{}) { fmt.Println(i...) },

		ErrRetry: &ProxyErrRetry{
			Max:      math.MaxInt - 10,
			Interval: 1 * time.Second,
			Count:    0,
		},
	}
}

func (p *Proxy) GetServerUrl() string {
	if p.ServerUrl != "" {
		return p.ServerUrl
	}
	u, err := url.Parse(p.ProxyUrl)
	if err != nil {
		panic(err)
	}
	u.Path = path.Join("/proxy", p.Auth.ID) + "/"
	p.ServerUrl = u.String()
	return p.ServerUrl
}

func (p *Proxy) Serve(h http.Handler) {
	if h == nil {
		h = http.DefaultServeMux
	}
	p.handler = h
	var wg sync.WaitGroup
	for i := 0; i < p.Parallel; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := p.serveLoop()
			if err != nil {
				p.Println(err)
			}
		}()
	}
	wg.Wait()
}

func (p *Proxy) serveLoop() (err error) {
	var init *fetch.RequestInit = nil
	for {
		init, err = p.serve(init)
		if err != nil {
			p.Println(err)
		}
		if init == nil {
			break
		}
	}
	return
}

func (p *Proxy) retry(err error) (*fetch.RequestInit, error) {
	r := p.ErrRetry
	if r.Count > r.Max {
		return nil, fmt.Errorf("err retry count is more than retry max. err: %w", err)
	}
	r.Count++
	time.Sleep(r.Interval)
	return p.defaultRequestInit(), err
}

func (p *Proxy) defaultRequestInit() *fetch.RequestInit {
	return handler.MakeRequestInit(p.Auth.Secret, http.Header{}, nil)
}

func (p *Proxy) serve(init *fetch.RequestInit) (rinit *fetch.RequestInit, err error) {
	if init == nil {
		init = p.defaultRequestInit()
	}
	resp, err := fetch.Run(p.Client, p.GetServerUrl(), init)
	if err != nil {
		return p.retry(err)
	}
	if resp.StatusCode != 200 {
		err = fmt.Errorf("HttpRelay responded %v while returning result and requesting new job", resp.StatusCode)
		if resp.StatusCode >= 500 && resp.StatusCode <= 599 {
			return p.retry(err)
		}
		if resp.StatusCode == 406 {
			err = fmt.Errorf("client is gone, nowhere to forward the response. err: %w", err)
			// contine
			rinit = p.defaultRequestInit()
			return
		}
		// don't continue
		if resp.StatusCode == 401 {
			err = fmt.Errorf("make sure that provided `wSecret` is correct. If not set, it is autogenerated each time `proxy` object is created and most of the time it is the reason you get this error. err: %w", err)
			return
		}
		return
	}
	p.ErrRetry.Count = 0
	h := handler.Handler{
		Handler: p.handler,
		Secret:  p.Auth.Secret,
	}
	hreq, err := handler.NewRequest(resp)
	if err != nil {
		return p.retry(err)
	}
	ctx := handler.Context{Request: hreq, Secret: h.Secret}
	rinit = h.Execute(ctx)
	return
}
